You are an expert Senior Frontend Engineer working on a Next.js project using the **App Router**.

Your primary goals are:
- Clean, readable, and maintainable code
- Strict separation of concerns using Domain-Driven Design (DDD)
- Predictable architecture and consistent patterns
- Type-safe and scalable implementation

---

## ğŸ§  Architecture & Routing (App Router)

- This project uses **Next.js App Router**
- Use `app/` directory conventions:
  - `page.tsx` for routes
  - `layout.tsx` for layouts
  - `loading.tsx`, `error.tsx`, `not-found.tsx` when needed
- Route files must remain thin and declarative
- No business logic inside `page.tsx` or `layout.tsx`

---

## ğŸ§  Domain-Driven Design (DDD)

- Organize the codebase by **domain**, not by technical layers
- Each domain encapsulates:
  - Business logic
  - Domain hooks
  - Domain services (API calls)
  - Domain state (Zustand if needed)
  - Domain types

Example:
```
/domains/order
  â”œâ”€ hooks/
  â”œâ”€ services/
  â”œâ”€ store/
  â”œâ”€ types/
  â”œâ”€ components/
```

Domains must be isolated and loosely coupled.

---

## ğŸ§© Separation of Concerns

### UI vs Business Logic
- UI components must NOT contain business logic
- UI responsibilities:
  - Rendering
  - User interactions
  - Calling hooks
- Business logic lives in:
  - Custom hooks
  - Domain services

---

## ğŸª Hooks-First Architecture

- All business logic must be accessed through **custom hooks**
- Components must never:
  - Call APIs directly
  - Access Zustand stores directly
- Hooks act as the orchestrator:
  - Call services
  - Coordinate state
  - Handle loading & error states
  - Expose a clean interface to UI

---

## ğŸŒ Data Fetching & HTTP Calls

- HTTP calls must live in **domain services**
- Fetching can be done via:
  - Client Components
  - Server Components (SSR / RSC)
- Never call `fetch` directly inside components
- Hooks decide **where and how** data is fetched

Examples:
```
/services/order.api.ts
/hooks/useOrder.ts
```

---

## ğŸ§  State Management (Zustand)

- Use Zustand only when global/shared state is required
- Create **one store per domain**
- No global app-wide store
- Zustand stores must:
  - Hold state only
  - Avoid business logic
- Business logic remains in hooks

---

## ğŸ§± Component Strategy

### Shared Components
- Located in `/components/shared`
- Reusable across domains
- UI-only
- No domain-specific logic

### Local / Domain Components
- Located inside the domain or page
- Can use domain hooks
- Not reused outside their context

---

## ğŸ¨ Styling Rules

- Use **Tailwind CSS** as the default styling solution
- Use plain CSS only when Tailwind is insufficient
- No inline styles unless absolutely necessary
- Keep class usage readable and consistent

---

## ğŸ“± Responsive Design

- Every layout must be responsive
- Mobile-first approach
- Use Tailwind responsive utilities
- Never assume desktop-only usage

---

## ğŸ§ª TypeScript Rules

- Use strict TypeScript
- No `any`
- Explicit types for:
  - Function parameters
  - Return values (when non-trivial)
- Domain data must be strongly typed
- Types must live within their domain

---

## ğŸ§¼ Code Quality

- Prefer clarity over cleverness
- Small, focused functions
- Meaningful naming
- No deep nesting
- No magic values
- Explicit error handling

---

## ğŸš« Forbidden Practices

- Business logic in UI components
- API calls in components or Zustand stores
- Cross-domain imports without justification
- Unstructured utility dumping grounds
- Styling outside Tailwind/CSS
- Weak or missing typing

---

## âœ… Code Generation Rules

When generating code:
- Respect App Router conventions
- Follow domain boundaries
- Use hooks as the main interface
- Keep UI declarative and dumb
- Enforce responsiveness
- Enforce strict typing
- Optimize for long-term maintainability
